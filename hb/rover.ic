/*
  Based on Test program for Handy Board - hbtest.ic by
  Fred G. Martin (fredm@media.mit.edu)

    
*/

#define TESTNUM 8

#use "serialio7.ic"

int ver = 2;

void 
menu()
{
    char a[TESTNUM][16]={"Menu: Serial","Menu: Motors","Menu: Servo","Menu: Digitals",
          "Menu: Analogs", "Menu: Knob", "Menu: IR", "Menu: Sonar"};
    tone(700.,.5);
    printf("Squawky Rover .%dPress START\n", ver);
    while(!start_button());
    while(1) {
        int sel;
        beep();        
        printf("Turn knob to    select test\n");
        sleep(1.0);
        sel = select_string(a,TESTNUM);
        if (sel >= 0)
          menuCommand(sel);
    }
    printf("Done\n");
}

void timer(int n)
{
    int i, j;
    float f;
    reset_system_time();
    for (i = 0; i < n; i++) {
    };
    f = (float)mseconds();
    printf("%f",f);
}

void main()
{
    start_process(menu(),255);
}

int menuCommand(int sel)
{
    switch(sel) 
      {
        case 0: serialConsole(); break;
        case 1: testmotors(); break;
        case 2: testservo(); break;
        case 3: testdigitals(); break;
        case 4: testanalogs(); break;
        case 5: testknob(); break;
        case 6: testir(); break;
        case 7: testsonar(); break;
        default: return 1;
    }
    return 0;
}

/* integer to string */
int its (int i, char s[])
{
    int c, d, x, n;
    n = _array_size(s) - 1; // leave room for \0
    while (n > 0) {
        s[c++] = (i % 10) + '0';
        n--; 
        i /= 10;
        if (i == 0) break;
    }
    s[c] = '\0';
    while (d < --c) { // flip digits
        x = s[d]; s[d] = s[c]; s[c] = x;
        d++;
    }
    return n; // Amount of space left...
}

int serial_put(char buf[])
{
    int i, rc;
    int n = _array_size(buf);
    while ((i < n) && buf[i])
      rc += serial_putchar(100, buf[i++]);
    return rc;
}

/*
// get a string until '\n' or max 
int serial_get(char buf[], int max)
{
    int i, rc, c;
    while (i < max) {
        rc = serial_getchar(100, &c);
        if (rc == 1) { // got a character
            //tone(1200., .1);
            if (c == 13) {// got \n
                buf[i] = 0;
                break;
            }
            buf[i++] = c;
        }
    }
    serial_put(buf); // echo it back
    return i;
}
*/
// get a string until '\n' or max 
int serial_get(char buf[])
{
    int i, j, c;
    int n = _array_size(buf);
    while (i < n) {
        while (!(peek(0x102e) & 0x20));           /* wait until a character arrives */
        c = peek(0x102f);              /* return it as an int */ 
        if (c == '.') {
            hog_processor();
        } else {    
            if (c == 13) {  // got \r
                buf[i] = 0;
                break;
            }
            buf[i++] = c;
        }
    }
    serial_put(buf);
    return i;
}

#define BUFLEN 32
char buf[BUFLEN];

int isDigit(int x) { return x >= '0' && x <= '9'; }

void
serialConsole(void)
{
    int i, rc, sel, cnt, err;
    char cmd[BUFLEN], s[BUFLEN];
    printf("Serail console  HoldSTOP to end\n");
    disable_pcode_serial();
    while (!stop_button()) {
        err = 0;
        sleep(.5);
        printf(">");
        rc = serial_put(">");
        tone(1100., .1);tone(1100., .1);
        rc = serial_get(cmd);
        rc = its(cnt++, s);
        serial_put("\r\n["); serial_put(s); serial_put("]");
        if (isDigit(cmd[0]) && cmd[1] == 0) {
            tone(800., .2);
            err = menuCommand(cmd[0]-'0');
            while (stop_button()); // wait for stop button to be released
        }
        else {
            err = carCommand(cmd);
        }
        if (err) {
            tone(300., .5);
            printf("\nInvalid cmd:[%s]", cmd);
        }
    }
    enable_pcode_serial();
}

int power = 50;

void leftFwd() { motor(0, power); motor(2, power); }
void rightFwd() { motor(1, power); motor(3, power); }
void leftBack() { motor(0, -power); motor(2, -power); }
void rightBack() { motor(1, -power); motor(3, -power); }

int carCommand(char cmd[])
{
    int err = 0;
    if (cmd[1] == 0) { // 1 char commands
        if (cmd[0] == 'f') { leftFwd(); rightFwd(); }
        else if (cmd[0] == 'b') { leftBack(); rightBack(); }
        else if (cmd[0] == 'l') { leftFwd(); rightBack(); }
        else if (cmd[0] == 'r') { leftBack(); rightFwd(); }
        else if (cmd[0] == 'o') { ao(); }
        else err = 1;
    } else if (cmd[2] == 0) { // 2 char commands        
        if (cmd[0] == 'p' && isDigit(cmd[1])) { power = (cmd[1]-'0'+1)*10; }
        else err = 1;
    } else
        err = 1;
    return err;
}

void
testmotors(void)
{
    printf("Motor test, HoldSTOP to end    \n");
    while (!stop_button()) {
        int i;
        for (i= 0; (!stop_button() && (i< 2)); i++) {
            motor(i,70); msleep(250L);
            off(i);
            motor(i+2,70); msleep(250L);
            off(i+2);
        }
        for (i= 0; (!stop_button() && (i< 2)); i++) {
            motor(i,-70); msleep(250L);
            off(i);
            motor(i+2,-70); msleep(250L);
            off(i+2);
        }
    }
}

void 
testservo(void)
{
    int i;
    printf("Attach Servos   Press START\n");
    while(!start_button());
    init_expbd_servos(1);
    while(!stop_button()) 
      for (i=0;(!stop_button() && i<4000);i=i+100) {
          printf("Hold STOP to end Servo=%d\n",i);
          servo0=servo1=servo2=servo3=servo4=servo5=i;
          msleep(50L);
      }
    init_expbd_servos(0);
}


void
testdigitals(void)
{
    printf("Digital inputs  STOP to end\n");
    sleep(1.0);
    printf("Turn knob to    select port\n");
    sleep(1.0);
    while (!stop_button()) {
        /* Get the value of the knob.  The digital port numbering is 7-15 */
        int val = knob_int_value(6, 15);
        
        if(val == 6) {   /* show all */
            int i;
            printf("Ports 15 ...  7       ");
            for (i=15; i>6; i--)
              if (digital(i)) printf("1");
              else printf("0");
            printf("\n");
        }
        else {
            printf("Port %d: %d\n", val, digital(val));
        }
        msleep(100L);
    }
}

void
testknob(void)
{
    while (!stop_button()) {
        printf("Turn knob; STOP to end -> %d\n", knob());
        msleep(100L);
    }
}

void
testsonar(void)
{
    while (!stop_button()) {
        printf("Test sonar; STOP to end -> %d\n", sonar());
        msleep(100L);
    }
} 

void
testanalogs(void)
{
    printf("Analog ins;     STOP to end\n");
    sleep(1.0);
    printf("Turn knob to    select port\n");
    sleep(1.0);
    while (!stop_button()) {
        /* Get the value of the knob.  The A/D numbering is 2-6, then 
    16-31.  Since this is discontinuous, get continuous number
    between 2 and 22, and then add 9 to any number > 6 */
        int val = knob_int_value(2, 22);
        
        if(val>6){
            val = val + 9;
        }
        
        printf("Port %d: %d\n", val, analog(val));
        msleep(100L);
    }
}


void hb_ir_transmit_on()
{
    bit_set(0x1000,0b01000000);
}

void hb_ir_transmit_off()
{
    bit_clear(0x1000,0b01000000);
}

void blinkIR(float x)
{
    hb_ir_transmit_on();
    sleep(x);
    hb_ir_transmit_off();
    sleep(x);
}

void testir()
{
    printf("Blinking IR xmit STOP to stop\n");
    while(!stop_button())
      blinkIR(.1);
}

/****************************** hbmenu.c ********************************/
/* Menu functions which also allow variables to be set via the knob
   and selection buttons  

   Version 1.0 
   Written for MIT 6.270 contest by Anne Wright 11/14/1991 

   Version 2.0
   Converted for Handy Board for Botball by Anne Wright 1/13/2001
*/

/* abstractions for chosen_button */
#define NEITHER_B 0
#define START_B  1
#define STOP_B  2

/* abstractions for wait_button */
#define UP_B      3
#define DOWN_B    4
#define CYCLE_B   5

/*****************************button routines*************************/
/* Return minimum of two integers */
/* defined in cmucam3.ic which is loaded by this file -dpm 1/03 */
int min(int a,int b)
{
    if(a<b)
      return(a);
    else
      return(b);
}

/* Return minimum of two floats */
float fmin(float a,float b)
{
    if(a<b)
      return(a);
    else
      return(b);
}

/* Returns which button is depressed using definitions above.  If
   both are pressed, start has precedence */
int chosen_button()
{
    if(start_button())
      return START_B;
    if(stop_button())
      return STOP_B;
    return NEITHER_B;
}  

/* wait until button is depressed(DOWN_B), released(UP_B), or
   both(CYCLE_B) and return which button if any activated the
   sequence */

int wait_button(int i)
{
    int b;
    if(i==DOWN_B){
        while(!(start_button() || stop_button()));
        return chosen_button();
    }
    if (i==UP_B) {
        b=chosen_button();
        while(start_button() || stop_button());
        return b;
    }
    while(!(start_button() || stop_button()));
    b=chosen_button();
    while(start_button() || stop_button());
    return b;
} 

/********************* Knob to Number routines*****************************/

/* Returns an integer value from min_val to max_val based on the current
   position of the knob */  
int knob_int_value(int min_val,int max_val)
{
    int val, coarseness=(255)/(max_val-min_val),selection;
    
    val=min((knob())/coarseness+min_val,max_val);
    return min(val,max_val);
}

/* Returns an float value from min_val to max_val based on the current
   position of the knob */  
float knob_float_value(float min_val,float max_val)
{
    float val, coarseness=(255.)/(max_val-min_val),selection;
    val=fmin(((float)knob())/coarseness+min_val,max_val);
    return fmin(val,max_val);
}

/******************** Menu selection routines ****************************/

/* While waiting for a button press, display the string passed in and
   the val, the integer value betwen min_val and max_val for the knob.
   If the button pressed is the start button, returns the final value
   of val.  If the button pressed is the stop button, returns -1.  */
int select_int_value(char s[],int min_val,int max_val)
{
    int val, button;
    
    printf("%s %d to %d\n",s,min_val, max_val);
    sleep(0.8);
    
    /* Wait until no button is pressed */
    wait_button(UP_B);
    
    /* While no button is pressed, display the string passed in and the
       current value of val */
    while((button = chosen_button())==NEITHER_B) {
        val=knob_int_value(min_val,max_val);
        printf("%s %d\n",s,val);
        msleep(100L);
    }
    
    /* Wait until no button is pressed */
    wait_button(UP_B);
    
    if(button==STOP_B)
      return(-1); /** -1 means stop pressed -- do not reset value **/
    else
      return(val); /* Stop not pressed, return val */
}

/* While waiting for a button press, display the string passed in and
   the val, the float value betwen min_val and max_val for the knob.
   If the button pressed is the start button, returns the final value
   of val.  If the button pressed is the stop button, returns -1.  */
float select_float_value(char s[],float min_val,float max_val)
{
    float val;
    int button;
    
    printf("%s %f to %f\n",s,min_val, max_val);
    sleep(0.8);
    
    /* Wait until no button is pressed */
    wait_button(UP_B);
    
    /* While no button is pressed, display the string passed in and the
       current value of val */
    while((button = chosen_button())==NEITHER_B) {
        val=knob_float_value(min_val,max_val);
        printf("%s %f\n",s,val);
        msleep(100L);
    }
    
    /* Wait until no button is pressed */
    wait_button(UP_B);
    
    if(button==STOP_B)
      return(-1.0); /** -1 means stop pressed -- do not reset value **/
    else
      return(val); /* Stop not pressed, return val */
}

/* While waiting for a button press, display the string from the array
   of strings passed in which corresponds to the current position of
   the knob (see select_int_value).  If the button pressed is the
   start button, returns the index of the string selected (0 to n-1).
   If the button pressed is the stop button, returns -1.  */
int select_string(char choices[][],int n)
{
    int selection,last_selection=-1,button;
    
    if(n>_array_size(choices))
      n=_array_size(choices);
    
    
    /* Wait until no button is pressed */
    wait_button(UP_B);
    
    /* While no button is pressed, display the string from the array
       of strings passed in which corresponds to the current position
       of the knob */
    while((button = chosen_button())==NEITHER_B) {
        selection=knob_int_value(0,n-1);
        if(selection!=last_selection) {
            printf("%s\n",choices[selection]);
            msleep(150L);
            last_selection=selection;
        }
    }
    
    /* Wait until no button is pressed */
    wait_button(UP_B);
    
    if(button==STOP_B)
      return(-1); /** -1 means stop pressed -- do not reset value **/
    else
      return(selection); /* Stop not pressed, return val */
}

/*
 * Local variables:
 *  comment-column: 40
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 */
